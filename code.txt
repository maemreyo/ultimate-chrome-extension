// src/modules/ui-components/index.ts
export * from './floating-icon'
export * from './context-menu'
export * from './sidebar'
export * from './mini-menu'
export * from './loading-states'
export * from './notifications'
export * from './hooks'
export * from './providers'
export * from './types'

// src/modules/ui-components/types.ts
import { ReactNode } from 'react'

export interface Position {
  x: number
  y: number
}

export interface Rect {
  top: number
  left: number
  width: number
  height: number
  right: number
  bottom: number
}

export interface FloatingIconConfig {
  icon: ReactNode
  tooltip?: string
  onClick?: () => void
  onHover?: () => void
  position?: 'left' | 'right'
  offset?: number
  showOn?: 'hover' | 'always' | 'selection'
  className?: string
  delay?: number
}

export interface ContextMenuItem {
  id: string
  label: string
  icon?: ReactNode
  shortcut?: string
  disabled?: boolean
  danger?: boolean
  separator?: boolean
  onClick?: () => void
  children?: ContextMenuItem[]
}

export interface SidebarConfig {
  position?: 'left' | 'right'
  width?: number | string
  minWidth?: number
  maxWidth?: number
  resizable?: boolean
  collapsible?: boolean
  defaultCollapsed?: boolean
  overlay?: boolean
  pushContent?: boolean
  className?: string
  zIndex?: number
}

export interface NotificationConfig {
  id?: string
  title?: string
  message: string
  type?: 'info' | 'success' | 'warning' | 'error'
  duration?: number
  closable?: boolean
  action?: {
    label: string
    onClick: () => void
  }
  icon?: ReactNode
  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'top-center' | 'bottom-center'
}

// src/modules/ui-components/floating-icon.tsx
import React, { useState, useEffect, useRef, useMemo } from 'react'
import { createPortal } from 'react-dom'
import { motion, AnimatePresence } from 'framer-motion'
import { FloatingIconConfig, Position } from './types'
import { cn } from '~lib/utils'

interface FloatingIconProps extends FloatingIconConfig {
  targetElement: HTMLElement | null
  isVisible?: boolean
}

export function FloatingIcon({
  targetElement,
  icon,
  tooltip,
  onClick,
  onHover,
  position = 'left',
  offset = 20,
  showOn = 'hover',
  className,
  delay = 300,
  isVisible: externalIsVisible
}: FloatingIconProps) {
  const [isVisible, setIsVisible] = useState(false)
  const [iconPosition, setIconPosition] = useState<Position>({ x: 0, y: 0 })
  const timeoutRef = useRef<NodeJS.Timeout>()
  const iconRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!targetElement) return

    const updatePosition = () => {
      const rect = targetElement.getBoundingClientRect()
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft

      const x = position === 'left'
        ? rect.left + scrollLeft - offset - 40 // 40 is icon width
        : rect.right + scrollLeft + offset

      const y = rect.top + scrollTop + (rect.height / 2) - 20 // Center vertically

      setIconPosition({ x, y })
    }

    const handleMouseEnter = () => {
      if (showOn === 'hover') {
        timeoutRef.current = setTimeout(() => {
          setIsVisible(true)
          updatePosition()
        }, delay)
      }
    }

    const handleMouseLeave = () => {
      if (showOn === 'hover') {
        clearTimeout(timeoutRef.current)
        setIsVisible(false)
      }
    }

    const handleSelection = () => {
      if (showOn === 'selection') {
        const selection = window.getSelection()
        if (selection && selection.toString().trim() && targetElement.contains(selection.anchorNode)) {
          updatePosition()
          setIsVisible(true)
        } else {
          setIsVisible(false)
        }
      }
    }

    // Event listeners
    targetElement.addEventListener('mouseenter', handleMouseEnter)
    targetElement.addEventListener('mouseleave', handleMouseLeave)

    if (showOn === 'selection') {
      document.addEventListener('selectionchange', handleSelection)
    }

    // Update position on scroll/resize
    window.addEventListener('scroll', updatePosition, true)
    window.addEventListener('resize', updatePosition)

    // Initial setup
    if (showOn === 'always') {
      setIsVisible(true)
      updatePosition()
    }

    return () => {
      clearTimeout(timeoutRef.current)
      targetElement.removeEventListener('mouseenter', handleMouseEnter)
      targetElement.removeEventListener('mouseleave', handleMouseLeave)
      document.removeEventListener('selectionchange', handleSelection)
      window.removeEventListener('scroll', updatePosition, true)
      window.removeEventListener('resize', updatePosition)
    }
  }, [targetElement, position, offset, showOn, delay])

  // Handle external visibility control
  useEffect(() => {
    if (externalIsVisible !== undefined) {
      setIsVisible(externalIsVisible)
    }
  }, [externalIsVisible])

  const portalElement = useMemo(() => {
    const container = document.getElementById('extension-portal-container')
    if (container) return container

    const newContainer = document.createElement('div')
    newContainer.id = 'extension-portal-container'
    document.body.appendChild(newContainer)
    return newContainer
  }, [])

  if (!targetElement) return null

  return createPortal(
    <AnimatePresence>
      {isVisible && (
        <motion.div
          ref={iconRef}
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
          transition={{ duration: 0.2 }}
          style={{
            position: 'absolute',
            left: iconPosition.x,
            top: iconPosition.y,
            zIndex: 9999
          }}
          className={cn(
            'flex items-center justify-center w-10 h-10 bg-white dark:bg-gray-800 rounded-full shadow-lg cursor-pointer hover:shadow-xl transition-shadow',
            className
          )}
          onClick={onClick}
          onMouseEnter={onHover}
        >
          {icon}
          {tooltip && (
            <div className="absolute bottom-full mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded whitespace-nowrap opacity-0 hover:opacity-100 transition-opacity pointer-events-none">
              {tooltip}
              <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" />
            </div>
          )}
        </motion.div>
      )}
    </AnimatePresence>,
    portalElement
  )
}

// Hook for easy usage
export function useFloatingIcon(config: FloatingIconConfig) {
  const [targetElement, setTargetElement] = useState<HTMLElement | null>(null)

  const attach = (element: HTMLElement) => {
    setTargetElement(element)
  }

  const detach = () => {
    setTargetElement(null)
  }

  const FloatingIconComponent = () => (
    <FloatingIcon {...config} targetElement={targetElement} />
  )

  return { attach, detach, FloatingIconComponent }
}

// src/modules/ui-components/context-menu.tsx
import React, { useState, useEffect, useRef } from 'react'
import { createPortal } from 'react-dom'
import { motion, AnimatePresence } from 'framer-motion'
import { ChevronRight } from 'lucide-react'
import { ContextMenuItem, Position } from './types'
import { cn } from '~lib/utils'

interface ContextMenuProps {
  items: ContextMenuItem[]
  position: Position
  onClose: () => void
  className?: string
}

export function ContextMenu({ items, position, onClose, className }: ContextMenuProps) {
  const menuRef = useRef<HTMLDivElement>(null)
  const [adjustedPosition, setAdjustedPosition] = useState(position)
  const [activeSubmenu, setActiveSubmenu] = useState<string | null>(null)

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        onClose()
      }
    }

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    document.addEventListener('keydown', handleEscape)

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
      document.removeEventListener('keydown', handleEscape)
    }
  }, [onClose])

  useEffect(() => {
    if (menuRef.current) {
      const rect = menuRef.current.getBoundingClientRect()
      const viewportWidth = window.innerWidth
      const viewportHeight = window.innerHeight

      let x = position.x
      let y = position.y

      // Adjust horizontal position
      if (x + rect.width > viewportWidth) {
        x = viewportWidth - rect.width - 10
      }

      // Adjust vertical position
      if (y + rect.height > viewportHeight) {
        y = viewportHeight - rect.height - 10
      }

      setAdjustedPosition({ x, y })
    }
  }, [position])

  const handleItemClick = (item: ContextMenuItem) => {
    if (!item.disabled && !item.children) {
      item.onClick?.()
      onClose()
    }
  }

  const renderMenuItem = (item: ContextMenuItem, index: number) => {
    if (item.separator) {
      return <div key={item.id || index} className="h-px bg-gray-200 dark:bg-gray-700 my-1" />
    }

    const hasChildren = item.children && item.children.length > 0

    return (
      <div
        key={item.id || index}
        className={cn(
          'relative px-3 py-2 text-sm cursor-pointer rounded-md transition-colors',
          'hover:bg-gray-100 dark:hover:bg-gray-700',
          item.disabled && 'opacity-50 cursor-not-allowed',
          item.danger && 'text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20'
        )}
        onClick={() => handleItemClick(item)}
        onMouseEnter={() => hasChildren && setActiveSubmenu(item.id)}
        onMouseLeave={() => hasChildren && setActiveSubmenu(null)}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            {item.icon && <span className="w-4 h-4">{item.icon}</span>}
            <span>{item.label}</span>
          </div>
          <div className="flex items-center gap-2">
            {item.shortcut && (
              <span className="text-xs text-gray-500 dark:text-gray-400">{item.shortcut}</span>
            )}
            {hasChildren && <ChevronRight className="w-4 h-4" />}
          </div>
        </div>

        {/* Submenu */}
        {hasChildren && activeSubmenu === item.id && (
          <div
            className={cn(
              'absolute left-full top-0 ml-1 min-w-[200px]',
              'bg-white dark:bg-gray-800 rounded-lg shadow-lg',
              'border border-gray-200 dark:border-gray-700 p-1'
            )}
          >
            {item.children.map((child, idx) => renderMenuItem(child, idx))}
          </div>
        )}
      </div>
    )
  }

  return createPortal(
    <AnimatePresence>
      <motion.div
        ref={menuRef}
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        transition={{ duration: 0.1 }}
        style={{
          position: 'fixed',
          left: adjustedPosition.x,
          top: adjustedPosition.y,
          zIndex: 10000
        }}
        className={cn(
          'min-w-[200px] bg-white dark:bg-gray-800 rounded-lg shadow-lg',
          'border border-gray-200 dark:border-gray-700 p-1',
          className
        )}
      >
        {items.map((item, index) => renderMenuItem(item, index))}
      </motion.div>
    </AnimatePresence>,
    document.body
  )
}

// Hook for context menu
export function useContextMenu() {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState<Position>({ x: 0, y: 0 })
  const [items, setItems] = useState<ContextMenuItem[]>([])

  const open = (event: MouseEvent, menuItems: ContextMenuItem[]) => {
    event.preventDefault()
    setPosition({ x: event.clientX, y: event.clientY })
    setItems(menuItems)
    setIsOpen(true)
  }

  const close = () => {
    setIsOpen(false)
  }

  const ContextMenuComponent = () =>
    isOpen ? <ContextMenu items={items} position={position} onClose={close} /> : null

  return { open, close, ContextMenuComponent }
}

// src/modules/ui-components/sidebar.tsx
import React, { useState, useEffect, useRef } from 'react'
import { motion, AnimatePresence, PanInfo } from 'framer-motion'
import { X, ChevronLeft, ChevronRight, GripVertical } from 'lucide-react'
import { SidebarConfig } from './types'
import { cn } from '~lib/utils'

interface SidebarProps extends SidebarConfig {
  isOpen: boolean
  onClose: () => void
  children: React.ReactNode
  title?: string
}

export function Sidebar({
  isOpen,
  onClose,
  children,
  title,
  position = 'right',
  width = 400,
  minWidth = 300,
  maxWidth = 600,
  resizable = true,
  collapsible = true,
  overlay = true,
  pushContent = false,
  className,
  zIndex = 9998
}: SidebarProps) {
  const [isCollapsed, setIsCollapsed] = useState(false)
  const [sidebarWidth, setSidebarWidth] = useState(
    typeof width === 'number' ? width : parseInt(width)
  )
  const [isResizing, setIsResizing] = useState(false)
  const sidebarRef = useRef<HTMLDivElement>(null)

  // Handle resize
  const handleResizeStart = () => {
    setIsResizing(true)
  }

  const handleResize = (event: MouseEvent) => {
    if (!isResizing) return

    const newWidth = position === 'left'
      ? event.clientX
      : window.innerWidth - event.clientX

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      setSidebarWidth(newWidth)
    }
  }

  const handleResizeEnd = () => {
    setIsResizing(false)
  }

  useEffect(() => {
    if (isResizing) {
      document.addEventListener('mousemove', handleResize)
      document.addEventListener('mouseup', handleResizeEnd)
      document.body.style.cursor = 'ew-resize'
      document.body.style.userSelect = 'none'

      return () => {
        document.removeEventListener('mousemove', handleResize)
        document.removeEventListener('mouseup', handleResizeEnd)
        document.body.style.cursor = ''
        document.body.style.userSelect = ''
      }
    }
  }, [isResizing])

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isOpen) {
        onClose()
      }
    }

    document.addEventListener('keydown', handleKeyPress)
    return () => document.removeEventListener('keydown', handleKeyPress)
  }, [isOpen, onClose])

  const sidebarVariants = {
    open: {
      x: 0,
      width: isCollapsed ? 50 : sidebarWidth,
      transition: { type: 'spring', damping: 30, stiffness: 300 }
    },
    closed: {
      x: position === 'left' ? -sidebarWidth - 50 : sidebarWidth + 50,
      transition: { type: 'spring', damping: 30, stiffness: 300 }
    }
  }

  return (
    <>
      {/* Overlay */}
      <AnimatePresence>
        {isOpen && overlay && !pushContent && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 0.5 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black"
            style={{ zIndex: zIndex - 1 }}
            onClick={onClose}
          />
        )}
      </AnimatePresence>

      {/* Sidebar */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            ref={sidebarRef}
            variants={sidebarVariants}
            initial="closed"
            animate="open"
            exit="closed"
            className={cn(
              'fixed top-0 h-full bg-white dark:bg-gray-900 shadow-xl',
              position === 'left' ? 'left-0' : 'right-0',
              className
            )}
            style={{
              zIndex,
              width: isCollapsed ? 50 : sidebarWidth
            }}
          >
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
              {!isCollapsed && (
                <>
                  <h2 className="text-lg font-semibold">{title}</h2>
                  <button
                    onClick={onClose}
                    className="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
                  >
                    <X className="w-5 h-5" />
                  </button>
                </>
              )}
              {collapsible && (
                <button
                  onClick={() => setIsCollapsed(!isCollapsed)}
                  className={cn(
                    'p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors',
                    isCollapsed && 'mx-auto'
                  )}
                >
                  {position === 'left' ? (
                    isCollapsed ? <ChevronRight className="w-5 h-5" /> : <ChevronLeft className="w-5 h-5" />
                  ) : (
                    isCollapsed ? <ChevronLeft className="w-5 h-5" /> : <ChevronRight className="w-5 h-5" />
                  )}
                </button>
              )}
            </div>

            {/* Content */}
            {!isCollapsed && (
              <div className="flex-1 overflow-y-auto p-4">
                {children}
              </div>
            )}

            {/* Resize Handle */}
            {resizable && !isCollapsed && (
              <div
                className={cn(
                  'absolute top-0 w-1 h-full cursor-ew-resize hover:bg-blue-500 transition-colors',
                  position === 'left' ? 'right-0' : 'left-0'
                )}
                onMouseDown={handleResizeStart}
              >
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
                  <GripVertical className="w-3 h-3 text-gray-400" />
                </div>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {/* Push content style */}
      {pushContent && isOpen && (
        <style jsx global>{`
          body {
            margin-${position}: ${isCollapsed ? 50 : sidebarWidth}px !important;
            transition: margin 0.3s ease;
          }
        `}</style>
      )}
    </>
  )
}

// Hook for sidebar
export function useSidebar(config?: Partial<SidebarConfig>) {
  const [isOpen, setIsOpen] = useState(false)

  const open = () => setIsOpen(true)
  const close = () => setIsOpen(false)
  const toggle = () => setIsOpen(!isOpen)

  const SidebarComponent = ({ children, title }: { children: React.ReactNode; title?: string }) => (
    <Sidebar
      {...config}
      isOpen={isOpen}
      onClose={close}
      title={title}
    >
      {children}
    </Sidebar>
  )

  return { isOpen, open, close, toggle, SidebarComponent }
}

// src/modules/ui-components/mini-menu.tsx
import React, { useState, useRef, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { ChevronDown } from 'lucide-react'
import { cn } from '~lib/utils'

interface MiniMenuItem {
  id: string
  label: string
  icon?: React.ReactNode
  onClick?: () => void
  disabled?: boolean
  selected?: boolean
}

interface MiniMenuProps {
  items: MiniMenuItem[]
  trigger?: React.ReactNode
  label?: string
  className?: string
  position?: 'bottom' | 'top' | 'left' | 'right'
  align?: 'start' | 'center' | 'end'
  offset?: number
}

export function MiniMenu({
  items,
  trigger,
  label,
  className,
  position = 'bottom',
  align = 'start',
  offset = 8
}: MiniMenuProps) {
  const [isOpen, setIsOpen] = useState(false)
  const menuRef = useRef<HTMLDivElement>(null)
  const triggerRef = useRef<HTMLButtonElement>(null)

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        menuRef.current &&
        triggerRef.current &&
        !menuRef.current.contains(event.target as Node) &&
        !triggerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const positionClasses = {
    bottom: `top-full mt-${offset / 4}`,
    top: `bottom-full mb-${offset / 4}`,
    left: `right-full mr-${offset / 4}`,
    right: `left-full ml-${offset / 4}`
  }

  const alignClasses = {
    start: position === 'bottom' || position === 'top' ? 'left-0' : 'top-0',
    center: position === 'bottom' || position === 'top' ? 'left-1/2 -translate-x-1/2' : 'top-1/2 -translate-y-1/2',
    end: position === 'bottom' || position === 'top' ? 'right-0' : 'bottom-0'
  }

  return (
    <div className="relative inline-block">
      <button
        ref={triggerRef}
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'flex items-center gap-1 px-3 py-2 rounded-md transition-colors',
          'hover:bg-gray-100 dark:hover:bg-gray-800',
          isOpen && 'bg-gray-100 dark:bg-gray-800',
          className
        )}
      >
        {trigger || (
          <>
            {label && <span className="text-sm">{label}</span>}
            <ChevronDown className={cn(
              'w-4 h-4 transition-transform',
              isOpen && 'rotate-180'
            )} />
          </>
        )}
      </button>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            ref={menuRef}
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.1 }}
            className={cn(
              'absolute z-50 min-w-[150px] py-1',
              'bg-white dark:bg-gray-800 rounded-md shadow-lg',
              'border border-gray-200 dark:border-gray-700',
              positionClasses[position],
              alignClasses[align]
            )}
          >
            {items.map((item) => (
              <button
                key={item.id}
                onClick={() => {
                  if (!item.disabled) {
                    item.onClick?.()
                    setIsOpen(false)
                  }
                }}
                disabled={item.disabled}
                className={cn(
                  'w-full px-3 py-2 text-left text-sm transition-colors',
                  'hover:bg-gray-100 dark:hover:bg-gray-700',
                  'disabled:opacity-50 disabled:cursor-not-allowed',
                  item.selected && 'bg-gray-100 dark:bg-gray-700 font-medium'
                )}
              >
                <div className="flex items-center gap-2">
                  {item.icon && <span className="w-4 h-4">{item.icon}</span>}
                  <span>{item.label}</span>
                </div>
              </button>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

// src/modules/ui-components/loading-states.tsx
import React from 'react'
import { motion } from 'framer-motion'
import { Loader2 } from 'lucide-react'
import { cn } from '~lib/utils'

interface LoadingProps {
  size?: 'sm' | 'md' | 'lg'
  text?: string
  className?: string
}

export function SpinnerLoading({ size = 'md', text, className }: LoadingProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  }

  return (
    <div className={cn('flex flex-col items-center justify-center gap-2', className)}>
      <Loader2 className={cn('animate-spin', sizeClasses[size])} />
      {text && <p className="text-sm text-gray-500 dark:text-gray-400">{text}</p>}
    </div>
  )
}

export function DotsLoading({ size = 'md', text, className }: LoadingProps) {
  const sizeClasses = {
    sm: 'w-2 h-2',
    md: 'w-3 h-3',
    lg: 'w-4 h-4'
  }

  return (
    <div className={cn('flex flex-col items-center justify-center gap-2', className)}>
      <div className="flex gap-1">
        {[0, 1, 2].map((index) => (
          <motion.div
            key={index}
            className={cn('bg-gray-400 dark:bg-gray-600 rounded-full', sizeClasses[size])}
            animate={{
              scale: [1, 1.2, 1],
              opacity: [0.5, 1, 0.5]
            }}
            transition={{
              duration: 1.2,
              repeat: Infinity,
              delay: index * 0.2
            }}
          />
        ))}
      </div>
      {text && <p className="text-sm text-gray-500 dark:text-gray-400">{text}</p>}
    </div>
  )
}

export function PulseLoading({ size = 'md', text, className }: LoadingProps) {
  const sizeClasses = {
    sm: 'w-8 h-8',
    md: 'w-12 h-12',
    lg: 'w-16 h-16'
  }

  return (
    <div className={cn('flex flex-col items-center justify-center gap-2', className)}>
      <div className="relative">
        <motion.div
          className={cn('absolute inset-0 bg-blue-400 rounded-full opacity-75', sizeClasses[size])}
          animate={{ scale: [0, 1.2], opacity: [0.75, 0] }}
          transition={{ duration: 1.5, repeat: Infinity }}
        />
        <div className={cn('bg-blue-500 rounded-full', sizeClasses[size])} />
      </div>
      {text && <p className="text-sm text-gray-500 dark:text-gray-400">{text}</p>}
    </div>
  )
}

export function SkeletonLoading({
  lines = 3,
  className
}: {
  lines?: number
  className?: string
}) {
  return (
    <div className={cn('space-y-3', className)}>
      {Array.from({ length: lines }).map((_, index) => (
        <div
          key={index}
          className="h-4 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"
          style={{ width: `${Math.random() * 40 + 60}%` }}
        />
      ))}
    </div>
  )
}

export function ProgressLoading({
  progress,
  text,
  className
}: {
  progress: number
  text?: string
  className?: string
}) {
  return (
    <div className={cn('w-full space-y-2', className)}>
      <div className="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
        <motion.div
          className="h-full bg-blue-500"
          initial={{ width: 0 }}
          animate={{ width: `${progress}%` }}
          transition={{ duration: 0.3 }}
        />
      </div>
      <div className="flex justify-between text-sm text-gray-500 dark:text-gray-400">
        {text && <span>{text}</span>}
        <span>{Math.round(progress)}%</span>
      </div>
    </div>
  )
}

// src/modules/ui-components/notifications.tsx
import React, { createContext, useContext, useState, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { motion, AnimatePresence } from 'framer-motion'
import { X, Info, CheckCircle, AlertTriangle, XCircle } from 'lucide-react'
import { NotificationConfig } from './types'
import { cn } from '~lib/utils'

interface NotificationContextValue {
  notify: (config: NotificationConfig) => void
  dismiss: (id: string) => void
  dismissAll: () => void
}

const NotificationContext = createContext<NotificationContextValue | null>(null)

export function NotificationProvider({ children }: { children: React.ReactNode }) {
  const [notifications, setNotifications] = useState<NotificationConfig[]>([])

  const notify = useCallback((config: NotificationConfig) => {
    const id = config.id || Date.now().toString()
    const notification = { ...config, id }

    setNotifications(prev => [...prev, notification])

    if (config.duration !== 0) {
      setTimeout(() => {
        dismiss(id)
      }, config.duration || 5000)
    }
  }, [])

  const dismiss = useCallback((id: string) => {
    setNotifications(prev => prev.filter(n => n.id !== id))
  }, [])

  const dismissAll = useCallback(() => {
    setNotifications([])
  }, [])

  return (
    <NotificationContext.Provider value={{ notify, dismiss, dismissAll }}>
      {children}
      <NotificationContainer notifications={notifications} onDismiss={dismiss} />
    </NotificationContext.Provider>
  )
}

export function useNotifications() {
  const context = useContext(NotificationContext)
  if (!context) {
    throw new Error('useNotifications must be used within NotificationProvider')
  }
  return context
}

interface NotificationContainerProps {
  notifications: NotificationConfig[]
  onDismiss: (id: string) => void
}

function NotificationContainer({ notifications, onDismiss }: NotificationContainerProps) {
  const positions = {
    'top-left': 'top-4 left-4',
    'top-right': 'top-4 right-4',
    'bottom-left': 'bottom-4 left-4',
    'bottom-right': 'bottom-4 right-4',
    'top-center': 'top-4 left-1/2 -translate-x-1/2',
    'bottom-center': 'bottom-4 left-1/2 -translate-x-1/2'
  }

  // Group notifications by position
  const groupedNotifications = notifications.reduce((acc, notification) => {
    const position = notification.position || 'top-right'
    if (!acc[position]) acc[position] = []
    acc[position].push(notification)
    return acc
  }, {} as Record<string, NotificationConfig[]>)

  return createPortal(
    <>
      {Object.entries(groupedNotifications).map(([position, items]) => (
        <div
          key={position}
          className={cn('fixed z-[10001]', positions[position as keyof typeof positions])}
        >
          <AnimatePresence>
            {items.map((notification) => (
              <Notification
                key={notification.id}
                notification={notification}
                onDismiss={() => onDismiss(notification.id!)}
              />
            ))}
          </AnimatePresence>
        </div>
      ))}
    </>,
    document.body
  )
}

interface NotificationProps {
  notification: NotificationConfig
  onDismiss: () => void
}

function Notification({ notification, onDismiss }: NotificationProps) {
  const icons = {
    info: <Info className="w-5 h-5 text-blue-500" />,
    success: <CheckCircle className="w-5 h-5 text-green-500" />,
    warning: <AlertTriangle className="w-5 h-5 text-yellow-500" />,
    error: <XCircle className="w-5 h-5 text-red-500" />
  }

  const bgColors = {
    info: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800',
    success: 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800',
    warning: 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800',
    error: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
  }

  const type = notification.type || 'info'

  return (
    <motion.div
      layout
      initial={{ opacity: 0, y: -20, scale: 0.95 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.2 } }}
      className={cn(
        'mb-4 p-4 rounded-lg shadow-lg border',
        'bg-white dark:bg-gray-800',
        bgColors[type],
        'min-w-[300px] max-w-[500px]'
      )}
    >
      <div className="flex items-start gap-3">
        {notification.icon || icons[type]}

        <div className="flex-1">
          {notification.title && (
            <h4 className="font-semibold mb-1">{notification.title}</h4>
          )}
          <p className="text-sm text-gray-600 dark:text-gray-300">
            {notification.message}
          </p>

          {notification.action && (
            <button
              onClick={notification.action.onClick}
              className="mt-2 text-sm font-medium text-blue-600 dark:text-blue-400 hover:underline"
            >
              {notification.action.label}
            </button>
          )}
        </div>

        {notification.closable !== false && (
          <button
            onClick={onDismiss}
            className="p-1 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
          >
            <X className="w-4 h-4" />
          </button>
        )}
      </div>
    </motion.div>
  )
}

// Simple toast-style notifications
export function toast(message: string, type: NotificationConfig['type'] = 'info') {
  // This is a standalone function that requires NotificationProvider to be set up
  const event = new CustomEvent('extension-notification', {
    detail: { message, type }
  })
  window.dispatchEvent(event)
}

// Notification listener component
export function NotificationListener() {
  const { notify } = useNotifications()

  React.useEffect(() => {
    const handler = (event: CustomEvent) => {
      notify({
        message: event.detail.message,
        type: event.detail.type,
        position: 'bottom-center'
      })
    }

    window.addEventListener('extension-notification' as any, handler)
    return () => window.removeEventListener('extension-notification' as any, handler)
  }, [notify])

  return null
}

// src/modules/ui-components/providers.tsx
import React from 'react'
import { NotificationProvider, NotificationListener } from './notifications'

export function ExtensionUIProvider({ children }: { children: React.ReactNode }) {
  return (
    <NotificationProvider>
      <NotificationListener />
      {children}
    </NotificationProvider>
  )
}

// src/modules/ui-components/hooks.ts
export { useFloatingIcon } from './floating-icon'
export { useContextMenu } from './context-menu'
export { useSidebar } from './sidebar'
export { useNotifications } from './notifications'

// Re-export common hook
export function useExtensionUI() {
  const notifications = useNotifications()
  const contextMenu = useContextMenu()
  const sidebar = useSidebar()

  return {
    notifications,
    contextMenu,
    sidebar
  }
}
