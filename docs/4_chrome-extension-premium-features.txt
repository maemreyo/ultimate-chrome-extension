// ===== UPDATED PACKAGE.JSON =====
// package.json (updated dependencies)
{
  "name": "ultimate-chrome-extension-premium",
  "displayName": "Ultimate Chrome Extension Premium",
  "version": "1.0.0",
  "description": "Premium Chrome extension with Stripe, Supabase, SidePanel & NewTab",
  "dependencies": {
    // ... existing dependencies ...
    "@supabase/supabase-js": "^2.39.3",
    "@stripe/stripe-js": "^2.2.0",
    "stripe": "^14.13.0",
    "react-hot-toast": "^2.4.1",
    "framer-motion": "^10.18.0",
    "recharts": "^2.10.3",
    "date-fns": "^3.2.0"
  },
  "manifest": {
    "permissions": [
      "storage",
      "tabs",
      "activeTab",
      "contextMenus",
      "notifications",
      "identity",
      "identity.email",
      "alarms",
      "sidePanel"
    ],
    "side_panel": {
      "default_path": "sidepanel.html"
    },
    "chrome_url_overrides": {
      "newtab": "newtab.html"
    },
    "oauth2": {
      "client_id": "$GOOGLE_OAUTH_CLIENT_ID",
      "scopes": [
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/userinfo.profile"
      ]
    },
    "web_accessible_resources": [
      {
        "resources": ["assets/*", "inject/*"],
        "matches": ["<all_urls>"]
      }
    ]
  }
}

// ===== UPDATED ENVIRONMENT VARIABLES =====
// .env.example
# API URLs
PLASMO_PUBLIC_API_URL=https://api.yourdomain.com
PLASMO_PUBLIC_SITE_URL=https://yourdomain.com

# Supabase
PLASMO_PUBLIC_SUPABASE_URL=https://xxxxxxxxxxxxx.supabase.co
PLASMO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Stripe
PLASMO_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_51...
PLASMO_PUBLIC_STRIPE_PRICING_TABLE_ID=prctbl_1...
PLASMO_PUBLIC_STRIPE_CUSTOMER_PORTAL_URL=https://billing.stripe.com/p/login/...
STRIPE_SECRET_KEY=sk_test_51...
STRIPE_WEBHOOK_SECRET=whsec_...

# Google OAuth
GOOGLE_OAUTH_CLIENT_ID=1234567890-xxx.apps.googleusercontent.com

# Extension
CRX_PUBLIC_KEY=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...

// ===== CORE: SUPABASE INTEGRATION =====
// src/core/supabase.ts
import { createClient } from "@supabase/supabase-js"
import { Storage } from "@plasmohq/storage"

// Database types
export interface Database {
  public: {
    Tables: {
      users: {
        Row: {
          id: string
          email: string
          full_name: string | null
          avatar_url: string | null
          subscription_status: "free" | "pro" | "premium"
          stripe_customer_id: string | null
          created_at: string
          updated_at: string
        }
        Insert: Omit<Database["public"]["Tables"]["users"]["Row"], "id" | "created_at" | "updated_at">
        Update: Partial<Database["public"]["Tables"]["users"]["Insert"]>
      }
      user_data: {
        Row: {
          id: string
          user_id: string
          title: string
          content: any
          url: string | null
          tags: string[]
          created_at: string
        }
        Insert: Omit<Database["public"]["Tables"]["user_data"]["Row"], "id" | "created_at">
        Update: Partial<Database["public"]["Tables"]["user_data"]["Insert"]>
      }
    }
  }
}

// Custom storage adapter for Supabase Auth
const storage = new Storage({
  area: "local"
})

const supabaseStorage = {
  getItem: async (key: string) => {
    const data = await storage.get(key)
    return data ? JSON.stringify(data) : null
  },
  setItem: async (key: string, value: string) => {
    await storage.set(key, JSON.parse(value))
  },
  removeItem: async (key: string) => {
    await storage.remove(key)
  }
}

// Create Supabase client
export const supabase = createClient<Database>(
  process.env.PLASMO_PUBLIC_SUPABASE_URL!,
  process.env.PLASMO_PUBLIC_SUPABASE_ANON_KEY!,
  {
    auth: {
      storage: supabaseStorage,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false
    }
  }
)

// Auth helpers
export const supabaseAuth = {
  async signIn(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    })
    if (error) throw error
    return data
  },

  async signUp(email: string, password: string, fullName?: string) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { full_name: fullName }
      }
    })
    if (error) throw error
    return data
  },

  async signInWithGoogle() {
    // This will be handled via Chrome Identity API
    const token = await chrome.identity.getAuthToken({ interactive: true })
    if (!token) throw new Error("No auth token received")
    
    const { data, error } = await supabase.auth.signInWithIdToken({
      provider: "google",
      token
    })
    if (error) throw error
    return data
  },

  async signOut() {
    const { error } = await supabase.auth.signOut()
    if (error) throw error
  },

  async getSession() {
    const { data, error } = await supabase.auth.getSession()
    if (error) throw error
    return data.session
  },

  onAuthStateChange(callback: (event: string, session: any) => void) {
    return supabase.auth.onAuthStateChange(callback)
  }
}

// Database helpers
export const db = {
  async getUserData(userId: string) {
    const { data, error } = await supabase
      .from("user_data")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
    
    if (error) throw error
    return data
  },

  async saveUserData(data: Database["public"]["Tables"]["user_data"]["Insert"]) {
    const { data: result, error } = await supabase
      .from("user_data")
      .insert(data)
      .select()
      .single()
    
    if (error) throw error
    return result
  },

  async deleteUserData(id: string) {
    const { error } = await supabase
      .from("user_data")
      .delete()
      .eq("id", id)
    
    if (error) throw error
  },

  async getUserProfile(userId: string) {
    const { data, error } = await supabase
      .from("users")
      .select("*")
      .eq("id", userId)
      .single()
    
    if (error) throw error
    return data
  },

  async updateUserProfile(userId: string, updates: Database["public"]["Tables"]["users"]["Update"]) {
    const { data, error } = await supabase
      .from("users")
      .update(updates)
      .eq("id", userId)
      .select()
      .single()
    
    if (error) throw error
    return data
  }
}

// ===== CORE: STRIPE INTEGRATION =====
// src/core/stripe.ts
import { loadStripe, Stripe } from "@stripe/stripe-js"
import { supabase } from "./supabase"

let stripePromise: Promise<Stripe | null>

export const getStripe = () => {
  if (!stripePromise) {
    stripePromise = loadStripe(process.env.PLASMO_PUBLIC_STRIPE_PUBLISHABLE_KEY!)
  }
  return stripePromise
}

export const stripeService = {
  async createCheckoutSession(priceId: string, userId: string) {
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) throw new Error("Not authenticated")

    const response = await fetch(`${process.env.PLASMO_PUBLIC_API_URL}/api/stripe/create-checkout`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${session.access_token}`
      },
      body: JSON.stringify({
        priceId,
        userId,
        successUrl: `${chrome.runtime.getURL("tabs/success.html")}?session_id={CHECKOUT_SESSION_ID}`,
        cancelUrl: chrome.runtime.getURL("tabs/pricing.html")
      })
    })

    if (!response.ok) throw new Error("Failed to create checkout session")
    
    const data = await response.json()
    return data.sessionId
  },

  async redirectToCheckout(sessionId: string) {
    const stripe = await getStripe()
    if (!stripe) throw new Error("Stripe not loaded")

    const { error } = await stripe.redirectToCheckout({ sessionId })
    if (error) throw error
  },

  async createCustomerPortalSession() {
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) throw new Error("Not authenticated")

    const response = await fetch(`${process.env.PLASMO_PUBLIC_API_URL}/api/stripe/create-portal`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${session.access_token}`
      }
    })

    if (!response.ok) throw new Error("Failed to create portal session")
    
    const data = await response.json()
    return data.url
  },

  async getSubscriptionStatus() {
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) throw new Error("Not authenticated")

    const response = await fetch(`${process.env.PLASMO_PUBLIC_API_URL}/api/stripe/subscription-status`, {
      headers: {
        "Authorization": `Bearer ${session.access_token}`
      }
    })

    if (!response.ok) throw new Error("Failed to get subscription status")
    
    const data = await response.json()
    return data
  }
}

// ===== SIDEPANEL IMPLEMENTATION =====
// src/sidepanel/index.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { Toaster } from "react-hot-toast"
import { ThemeProvider } from "~components/theme-provider"
import { SidePanelApp } from "./app"
import "~styles/globals.css"

const queryClient = new QueryClient()

function SidePanel() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="system">
        <SidePanelApp />
        <Toaster position="bottom-center" />
      </ThemeProvider>
    </QueryClientProvider>
  )
}

export default SidePanel

// src/sidepanel/app.tsx
import { useState, useEffect } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~components/ui/tabs"
import { Button } from "~components/ui/button"
import { ScrollArea } from "~components/ui/scroll-area"
import { Home, Search, BookmarkIcon, Settings, CreditCard } from "lucide-react"
import { useSupabaseAuth } from "~hooks/useSupabaseAuth"
import { QuickActions } from "./components/quick-actions"
import { SavedItems } from "./components/saved-items"
import { SearchPanel } from "./components/search-panel"
import { SubscriptionStatus } from "./components/subscription-status"

export function SidePanelApp() {
  const { user, isLoading } = useSupabaseAuth()
  const [activeTab, setActiveTab] = useState("home")
  
  // Get current tab info
  const [currentTab, setCurrentTab] = useState<chrome.tabs.Tab | null>(null)
  
  useEffect(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) setCurrentTab(tabs[0])
    })
    
    // Listen for tab changes
    const listener = (tabId: number, changeInfo: chrome.tabs.TabChangeInfo, tab: chrome.tabs.Tab) => {
      if (changeInfo.status === "complete") {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (tabs[0]) setCurrentTab(tabs[0])
        })
      }
    }
    
    chrome.tabs.onUpdated.addListener(listener)
    return () => chrome.tabs.onUpdated.removeListener(listener)
  }, [])
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    )
  }
  
  return (
    <div className="h-screen flex flex-col bg-background">
      {/* Header */}
      <div className="border-b p-4">
        <div className="flex items-center justify-between mb-2">
          <h1 className="text-lg font-semibold">Extension Panel</h1>
          <SubscriptionStatus />
        </div>
        {currentTab && (
          <p className="text-sm text-muted-foreground truncate">
            {currentTab.title}
          </p>
        )}
      </div>
      
      {/* Main Content */}
      <div className="flex-1 overflow-hidden">
        <Tabs value={activeTab} onValueChange={setActiveTab} className="h-full">
          <TabsList className="grid w-full grid-cols-5 px-4">
            <TabsTrigger value="home" className="px-2">
              <Home className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="search" className="px-2">
              <Search className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="saved" className="px-2">
              <BookmarkIcon className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="billing" className="px-2">
              <CreditCard className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="settings" className="px-2">
              <Settings className="h-4 w-4" />
            </TabsTrigger>
          </TabsList>
          
          <ScrollArea className="h-[calc(100vh-140px)]">
            <TabsContent value="home" className="p-4">
              <QuickActions currentTab={currentTab} />
            </TabsContent>
            
            <TabsContent value="search" className="p-4">
              <SearchPanel />
            </TabsContent>
            
            <TabsContent value="saved" className="p-4">
              <SavedItems userId={user?.id} />
            </TabsContent>
            
            <TabsContent value="billing" className="p-4">
              <BillingPanel />
            </TabsContent>
            
            <TabsContent value="settings" className="p-4">
              <SettingsPanel />
            </TabsContent>
          </ScrollArea>
        </Tabs>
      </div>
    </div>
  )
}

// src/sidepanel/components/subscription-status.tsx
import { useQuery } from "@tanstack/react-query"
import { Badge } from "~components/ui/badge"
import { stripeService } from "~core/stripe"

export function SubscriptionStatus() {
  const { data: status } = useQuery({
    queryKey: ["subscription-status"],
    queryFn: () => stripeService.getSubscriptionStatus(),
    refetchInterval: 60000 // Refresh every minute
  })
  
  const getStatusColor = () => {
    switch (status?.status) {
      case "active": return "bg-green-500"
      case "trialing": return "bg-blue-500"
      case "past_due": return "bg-yellow-500"
      default: return "bg-gray-500"
    }
  }
  
  return (
    <Badge className={getStatusColor()}>
      {status?.plan || "Free"}
    </Badge>
  )
}

// ===== NEWTAB IMPLEMENTATION =====
// src/newtab/index.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { ThemeProvider } from "~components/theme-provider"
import { NewTabApp } from "./app"
import "~styles/globals.css"

const queryClient = new QueryClient()

function NewTab() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="system">
        <NewTabApp />
      </ThemeProvider>
    </QueryClientProvider>
  )
}

export default NewTab

// src/newtab/app.tsx
import { useState, useEffect } from "react"
import { format } from "date-fns"
import { motion } from "framer-motion"
import { Search, Plus, Settings, TrendingUp, Calendar } from "lucide-react"
import { useSupabaseAuth } from "~hooks/useSupabaseAuth"
import { QuickLinks } from "./components/quick-links"
import { RecentActivity } from "./components/recent-activity"
import { SearchBar } from "./components/search-bar"
import { WeatherWidget } from "./components/weather-widget"
import { ProductivityStats } from "./components/productivity-stats"

export function NewTabApp() {
  const { user } = useSupabaseAuth()
  const [greeting, setGreeting] = useState("")
  const [currentTime, setCurrentTime] = useState(new Date())
  
  useEffect(() => {
    const updateGreeting = () => {
      const hour = new Date().getHours()
      if (hour < 12) setGreeting("Good morning")
      else if (hour < 18) setGreeting("Good afternoon")
      else setGreeting("Good evening")
    }
    
    updateGreeting()
    const interval = setInterval(() => {
      setCurrentTime(new Date())
      updateGreeting()
    }, 60000) // Update every minute
    
    return () => clearInterval(interval)
  }, [])
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-background to-muted">
      <div className="container mx-auto px-4 py-8 max-w-7xl">
        {/* Header */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-12"
        >
          <h1 className="text-5xl font-bold mb-2">
            {greeting}, {user?.user_metadata?.full_name || "there"}!
          </h1>
          <p className="text-2xl text-muted-foreground">
            {format(currentTime, "EEEE, MMMM d, yyyy")}
          </p>
          <p className="text-4xl font-mono mt-2">
            {format(currentTime, "HH:mm")}
          </p>
        </motion.div>
        
        {/* Search Bar */}
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.1 }}
          className="max-w-2xl mx-auto mb-12"
        >
          <SearchBar />
        </motion.div>
        
        {/* Widgets Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.2 }}
          >
            <QuickLinks />
          </motion.div>
          
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            <ProductivityStats />
          </motion.div>
          
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.4 }}
          >
            <WeatherWidget />
          </motion.div>
          
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
            className="lg:col-span-3"
          >
            <RecentActivity />
          </motion.div>
        </div>
      </div>
    </div>
  )
}

// ===== HOOKS UPDATE =====
// src/hooks/useSupabaseAuth.ts
import { useEffect, useState } from "react"
import { User } from "@supabase/supabase-js"
import { supabase, supabaseAuth } from "~core/supabase"
import { useStorage } from "./useStorage"

export function useSupabaseAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [, setStoredUser] = useStorage("user")
  
  useEffect(() => {
    // Get initial session
    supabaseAuth.getSession().then(session => {
      setUser(session?.user || null)
      if (session?.user) {
        setStoredUser({
          id: session.user.id,
          email: session.user.email!,
          name: session.user.user_metadata?.full_name || ""
        })
      }
      setIsLoading(false)
    })
    
    // Listen for auth changes
    const { data: { subscription } } = supabaseAuth.onAuthStateChange((event, session) => {
      setUser(session?.user || null)
      if (session?.user) {
        setStoredUser({
          id: session.user.id,
          email: session.user.email!,
          name: session.user.user_metadata?.full_name || ""
        })
      } else {
        setStoredUser(undefined)
      }
    })
    
    return () => subscription.unsubscribe()
  }, [])
  
  const signIn = async (email: string, password: string) => {
    const { user } = await supabaseAuth.signIn(email, password)
    return user
  }
  
  const signUp = async (email: string, password: string, fullName?: string) => {
    const { user } = await supabaseAuth.signUp(email, password, fullName)
    return user
  }
  
  const signInWithGoogle = async () => {
    const { user } = await supabaseAuth.signInWithGoogle()
    return user
  }
  
  const signOut = async () => {
    await supabaseAuth.signOut()
  }
  
  return {
    user,
    isLoading,
    isAuthenticated: !!user,
    signIn,
    signUp,
    signInWithGoogle,
    signOut
  }
}

// ===== MESSAGE HANDLERS UPDATE =====
// src/background/messages/stripe.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"
import { stripeService } from "~core/stripe"

export type StripeRequest = {
  action: "create-checkout" | "create-portal" | "get-status"
  priceId?: string
}

const handler: PlasmoMessaging.MessageHandler<StripeRequest> = async (req, res) => {
  const { action, priceId } = req.body
  
  try {
    switch (action) {
      case "create-checkout":
        if (!priceId) throw new Error("Price ID required")
        const sessionId = await stripeService.createCheckoutSession(priceId, req.sender.id)
        // Open checkout in new tab
        chrome.tabs.create({
          url: `https://checkout.stripe.com/pay/${sessionId}`
        })
        res.send({ success: true, sessionId })
        break
        
      case "create-portal":
        const portalUrl = await stripeService.createCustomerPortalSession()
        chrome.tabs.create({ url: portalUrl })
        res.send({ success: true, url: portalUrl })
        break
        
      case "get-status":
        const status = await stripeService.getSubscriptionStatus()
        res.send({ success: true, status })
        break
        
      default:
        res.send({ success: false, error: "Invalid action" })
    }
  } catch (error) {
    res.send({ success: false, error: error.message })
  }
}

export default handler

// src/background/messages/supabase.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"
import { supabase, db } from "~core/supabase"

export type SupabaseRequest = {
  action: "get-data" | "save-data" | "delete-data"
  table?: string
  data?: any
  id?: string
}

const handler: PlasmoMessaging.MessageHandler<SupabaseRequest> = async (req, res) => {
  const { action, table, data, id } = req.body
  
  try {
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      res.send({ success: false, error: "Not authenticated" })
      return
    }
    
    switch (action) {
      case "get-data":
        const items = await db.getUserData(session.user.id)
        res.send({ success: true, data: items })
        break
        
      case "save-data":
        const saved = await db.saveUserData({
          ...data,
          user_id: session.user.id
        })
        res.send({ success: true, data: saved })
        break
        
      case "delete-data":
        if (!id) throw new Error("ID required")
        await db.deleteUserData(id)
        res.send({ success: true })
        break
        
      default:
        res.send({ success: false, error: "Invalid action" })
    }
  } catch (error) {
    res.send({ success: false, error: error.message })
  }
}

export default handler

// ===== PRICING PAGE =====
// src/tabs/pricing.tsx
import { useState } from "react"
import { Check, X } from "lucide-react"
import { Button } from "~components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "~components/ui/card"
import { useSupabaseAuth } from "~hooks/useSupabaseAuth"
import { sendToBackground } from "@plasmohq/messaging"
import toast from "react-hot-toast"

const plans = [
  {
    name: "Free",
    price: "$0",
    description: "For personal use",
    features: [
      "Basic features",
      "Up to 100 saved items",
      "7 day history",
      "Basic support"
    ],
    limitations: [
      "No custom shortcuts",
      "No API access",
      "No priority support"
    ],
    priceId: null
  },
  {
    name: "Pro",
    price: "$9",
    period: "/month",
    description: "For power users",
    features: [
      "All Free features",
      "Unlimited saved items",
      "90 day history",
      "Custom shortcuts",
      "API access",
      "Priority support"
    ],
    limitations: [],
    priceId: "price_1234567890",
    popular: true
  },
  {
    name: "Premium",
    price: "$19",
    period: "/month",
    description: "For teams and businesses",
    features: [
      "All Pro features",
      "Unlimited history",
      "Team collaboration",
      "Advanced analytics",
      "Custom integrations",
      "24/7 phone support"
    ],
    limitations: [],
    priceId: "price_0987654321"
  }
]

export default function PricingPage() {
  const { user, isAuthenticated } = useSupabaseAuth()
  const [loading, setLoading] = useState<string | null>(null)
  
  const handleSubscribe = async (priceId: string | null) => {
    if (!priceId) return
    
    if (!isAuthenticated) {
      toast.error("Please sign in to subscribe")
      chrome.runtime.openOptionsPage()
      return
    }
    
    setLoading(priceId)
    try {
      await sendToBackground({
        name: "stripe",
        body: {
          action: "create-checkout",
          priceId
        }
      })
    } catch (error) {
      toast.error("Failed to start checkout")
      console.error(error)
    } finally {
      setLoading(null)
    }
  }
  
  return (
    <div className="min-h-screen bg-background py-12">
      <div className="container max-w-6xl mx-auto px-4">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold mb-4">Choose Your Plan</h1>
          <p className="text-xl text-muted-foreground">
            Unlock powerful features to enhance your browsing experience
          </p>
        </div>
        
        <div className="grid md:grid-cols-3 gap-8">
          {plans.map((plan) => (
            <Card
              key={plan.name}
              className={plan.popular ? "border-primary shadow-lg scale-105" : ""}
            >
              {plan.popular && (
                <div className="bg-primary text-primary-foreground text-center py-1 text-sm font-medium">
                  Most Popular
                </div>
              )}
              
              <CardHeader>
                <CardTitle className="text-2xl">{plan.name}</CardTitle>
                <CardDescription>{plan.description}</CardDescription>
                <div className="mt-4">
                  <span className="text-4xl font-bold">{plan.price}</span>
                  {plan.period && (
                    <span className="text-muted-foreground">{plan.period}</span>
                  )}
                </div>
              </CardHeader>
              
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  {plan.features.map((feature) => (
                    <div key={feature} className="flex items-start">
                      <Check className="h-5 w-5 text-green-500 mr-2 flex-shrink-0" />
                      <span className="text-sm">{feature}</span>
                    </div>
                  ))}
                  {plan.limitations.map((limitation) => (
                    <div key={limitation} className="flex items-start">
                      <X className="h-5 w-5 text-red-500 mr-2 flex-shrink-0" />
                      <span className="text-sm text-muted-foreground">{limitation}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
              
              <CardFooter>
                <Button
                  className="w-full"
                  variant={plan.popular ? "default" : "outline"}
                  onClick={() => handleSubscribe(plan.priceId)}
                  disabled={loading !== null || !plan.priceId}
                >
                  {loading === plan.priceId ? "Loading..." : 
                   plan.priceId ? "Subscribe" : "Current Plan"}
                </Button>
              </CardFooter>
            </Card>
          ))}
        </div>
        
        <div className="mt-12 text-center">
          <p className="text-muted-foreground mb-4">
            All plans include a 14-day free trial. Cancel anytime.
          </p>
          <Button
            variant="link"
            onClick={async () => {
              await sendToBackground({
                name: "stripe",
                body: { action: "create-portal" }
              })
            }}
          >
            Manage existing subscription
          </Button>
        </div>
      </div>
    </div>
  )
}

// ===== BACKGROUND SERVICE WORKER UPDATE =====
// src/background/index.ts (updated imports)
import "@plasmohq/messaging/background"
import { startHub } from "@plasmohq/messaging/pub-sub"
import { Storage } from "@plasmohq/storage"
import { supabase } from "~core/supabase"
import { setupAlarms } from "~core/alarms"
import { setupContextMenus } from "~core/context-menus"
import { setupNotifications } from "~core/notifications"

console.log("Background service worker started")

// Start messaging hub
startHub()

// Initialize core services
setupAlarms()
setupContextMenus()
setupNotifications()

// Initialize Supabase auth listener
supabase.auth.onAuthStateChange((event, session) => {
  console.log("Auth state changed:", event, session?.user?.email)
  
  if (event === "SIGNED_IN") {
    // User signed in
    chrome.action.setBadgeText({ text: "" })
  } else if (event === "SIGNED_OUT") {
    // User signed out
    chrome.action.setBadgeText({ text: "!" })
    chrome.action.setBadgeBackgroundColor({ color: "#ef4444" })
  }
})

// Handle extension installation
chrome.runtime.onInstalled.addListener(async (details) => {
  const storage = new Storage()
  
  if (details.reason === "install") {
    await storage.set("installed_at", new Date().toISOString())
    
    // Initialize Supabase session
    const { data: { session } } = await supabase.auth.getSession()
    if (session) {
      console.log("Existing session found:", session.user.email)
    }
    
    // Open welcome/onboarding page
    chrome.tabs.create({
      url: chrome.runtime.getURL("tabs/welcome.html")
    })
  }
})

// Handle side panel
chrome.sidePanel
  .setPanelBehavior({ openPanelOnActionClick: true })
  .catch((error) => console.error(error))

// ===== COMPONENTS FOR SIDEPANEL =====
// src/sidepanel/components/quick-actions.tsx
import { Button } from "~components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "~components/ui/card"
import { Bookmark, Copy, Share2, ExternalLink, Download } from "lucide-react"
import { sendToBackground } from "@plasmohq/messaging"
import toast from "react-hot-toast"

interface QuickActionsProps {
  currentTab: chrome.tabs.Tab | null
}

export function QuickActions({ currentTab }: QuickActionsProps) {
  const actions = [
    {
      icon: Bookmark,
      label: "Save Page",
      action: async () => {
        if (!currentTab) return
        
        const response = await sendToBackground({
          name: "supabase",
          body: {
            action: "save-data",
            data: {
              title: currentTab.title,
              url: currentTab.url,
              content: { favicon: currentTab.favIconUrl },
              tags: ["bookmark"]
            }
          }
        })
        
        if (response.success) {
          toast.success("Page saved!")
        }
      }
    },
    {
      icon: Copy,
      label: "Copy URL",
      action: () => {
        if (currentTab?.url) {
          navigator.clipboard.writeText(currentTab.url)
          toast.success("URL copied!")
        }
      }
    },
    {
      icon: Share2,
      label: "Share",
      action: async () => {
        if (navigator.share && currentTab) {
          try {
            await navigator.share({
              title: currentTab.title,
              url: currentTab.url
            })
          } catch (err) {
            console.log("Share cancelled")
          }
        }
      }
    }
  ]
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>Quick Actions</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-2">
          {actions.map((action, index) => (
            <Button
              key={index}
              variant="outline"
              size="sm"
              className="flex flex-col h-auto py-3"
              onClick={action.action}
            >
              <action.icon className="h-5 w-5 mb-1" />
              <span className="text-xs">{action.label}</span>
            </Button>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}

// src/sidepanel/components/billing-panel.tsx
import { useQuery } from "@tanstack/react-query"
import { Card, CardContent, CardHeader, CardTitle } from "~components/ui/card"
import { Button } from "~components/ui/button"
import { Progress } from "~components/ui/progress"
import { stripeService } from "~core/stripe"
import { sendToBackground } from "@plasmohq/messaging"

export function BillingPanel() {
  const { data: subscription, isLoading } = useQuery({
    queryKey: ["subscription"],
    queryFn: () => stripeService.getSubscriptionStatus()
  })
  
  const usagePercentage = subscription?.usage 
    ? (subscription.usage.current / subscription.usage.limit) * 100
    : 0
  
  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle>Current Plan</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between mb-2">
                <span className="text-lg font-medium">{subscription?.plan || "Free"}</span>
                <span className="text-muted-foreground">
                  ${subscription?.price || 0}/month
                </span>
              </div>
              {subscription?.status === "trialing" && (
                <p className="text-sm text-muted-foreground">
                  Trial ends {new Date(subscription.trialEnd).toLocaleDateString()}
                </p>
              )}
            </div>
            
            {subscription?.usage && (
              <div>
                <div className="flex justify-between text-sm mb-1">
                  <span>Storage Used</span>
                  <span>{subscription.usage.current} / {subscription.usage.limit}</span>
                </div>
                <Progress value={usagePercentage} className="h-2" />
              </div>
            )}
            
            <div className="flex gap-2">
              <Button
                variant="outline"
                className="flex-1"
                onClick={() => chrome.tabs.create({ url: "tabs/pricing.html" })}
              >
                Change Plan
              </Button>
              <Button
                variant="outline"
                className="flex-1"
                onClick={async () => {
                  await sendToBackground({
                    name: "stripe",
                    body: { action: "create-portal" }
                  })
                }}
              >
                Manage Billing
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}