// ===== PACKAGE.JSON =====
// package.json
{
  "name": "ultimate-chrome-extension",
  "displayName": "Ultimate Chrome Extension",
  "version": "1.0.0",
  "description": "A comprehensive Chrome extension with all features",
  "author": "Your Name",
  "scripts": {
    "dev": "plasmo dev",
    "build": "plasmo build",
    "build:firefox": "plasmo build --target=firefox-mv2",
    "package": "plasmo package",
    "test": "jest",
    "lint": "eslint src/**/*.{ts,tsx}",
    "format": "prettier --write src/**/*.{ts,tsx}"
  },
  "dependencies": {
    "@plasmohq/messaging": "^0.6.0",
    "@plasmohq/storage": "^1.9.0",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-switch": "^1.0.3",
    "@supabase/supabase-js": "^2.39.3",
    "@tanstack/react-query": "^5.17.15",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "lucide-react": "^0.303.0",
    "plasmo": "^0.84.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tailwind-merge": "^2.2.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@ianvs/prettier-plugin-sort-imports": "^4.1.1",
    "@types/chrome": "^0.0.258",
    "@types/jest": "^29.5.11",
    "@types/node": "^20.11.5",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "postcss": "^8.4.33",
    "prettier": "^3.2.4",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3"
  },
  "manifest": {
    "permissions": [
      "storage",
      "tabs",
      "activeTab",
      "contextMenus",
      "notifications",
      "identity",
      "alarms"
    ],
    "host_permissions": [
      "https://*/*",
      "http://localhost/*"
    ],
    "externally_connectable": {
      "matches": ["*://localhost/*", "*://*.yourdomain.com/*"]
    },
    "web_accessible_resources": [
      {
        "resources": ["assets/*", "inject/*"],
        "matches": ["<all_urls>"]
      }
    ]
  }
}

// ===== TSCONFIG.JSON =====
// tsconfig.json
{
  "extends": "plasmo/templates/tsconfig.base",
  "exclude": ["node_modules"],
  "include": [".plasmo/index.d.ts", "./**/*.ts", "./**/*.tsx"],
  "compilerOptions": {
    "paths": {
      "~*": ["./src/*"],
      "@/*": ["./src/*"]
    },
    "baseUrl": "."
  }
}

// ===== TAILWIND CONFIG =====
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{tsx,html}"],
  darkMode: ["class"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        }
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      }
    }
  },
  plugins: [require("tailwindcss-animate")]
}

// ===== BACKGROUND SERVICE WORKER =====
// src/background/index.ts
import "@plasmohq/messaging/background"
import { startHub } from "@plasmohq/messaging/pub-sub"
import { Storage } from "@plasmohq/storage"
import { initializeAuth } from "~core/auth"
import { setupAlarms } from "~core/alarms"
import { setupContextMenus } from "~core/context-menus"
import { setupNotifications } from "~core/notifications"

console.log("Background service worker started")

// Start messaging hub for pub-sub
startHub()

// Initialize core services
initializeAuth()
setupAlarms()
setupContextMenus()
setupNotifications()

// Handle extension installation
chrome.runtime.onInstalled.addListener(async (details) => {
  console.log("Extension installed:", details)
  
  const storage = new Storage()
  
  if (details.reason === "install") {
    // First time installation
    await storage.set("installed_at", new Date().toISOString())
    await storage.set("settings", {
      theme: "light",
      notifications: true,
      autoSync: true
    })
    
    // Open welcome page
    chrome.tabs.create({
      url: chrome.runtime.getURL("tabs/welcome.html")
    })
  } else if (details.reason === "update") {
    // Extension updated
    const previousVersion = details.previousVersion
    console.log(`Updated from ${previousVersion} to ${chrome.runtime.getManifest().version}`)
    
    // Show update notification
    chrome.notifications.create({
      type: "basic",
      iconUrl: chrome.runtime.getURL("assets/icon-128.png"),
      title: "Extension Updated!",
      message: `Updated to version ${chrome.runtime.getManifest().version}`
    })
  }
})

// Handle browser action click
chrome.action.onClicked.addListener((tab) => {
  // Toggle side panel or open popup
  chrome.sidePanel?.open({ windowId: tab.windowId })
})

// Keep service worker alive
chrome.alarms.create("keep-alive", { periodInMinutes: 1 })
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === "keep-alive") {
    console.log("Keep-alive ping")
  }
})

// ===== MESSAGE HANDLERS =====
// src/background/messages/ping.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"

const handler: PlasmoMessaging.MessageHandler = async (req, res) => {
  console.log("Ping received:", req.body)
  res.send({ message: "pong", timestamp: Date.now() })
}

export default handler

// src/background/messages/auth.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"
import { authManager } from "~core/auth"

export type AuthRequest = {
  action: "login" | "logout" | "check"
  credentials?: {
    email: string
    password: string
  }
}

const handler: PlasmoMessaging.MessageHandler<AuthRequest> = async (req, res) => {
  const { action, credentials } = req.body
  
  try {
    switch (action) {
      case "login":
        const user = await authManager.login(credentials!)
        res.send({ success: true, user })
        break
        
      case "logout":
        await authManager.logout()
        res.send({ success: true })
        break
        
      case "check":
        const isAuthenticated = await authManager.isAuthenticated()
        res.send({ success: true, isAuthenticated })
        break
        
      default:
        res.send({ success: false, error: "Invalid action" })
    }
  } catch (error) {
    res.send({ success: false, error: error.message })
  }
}

export default handler

// src/background/messages/api.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"
import { apiClient } from "~core/api"

export type ApiRequest = {
  endpoint: string
  method: "GET" | "POST" | "PUT" | "DELETE"
  data?: any
}

const handler: PlasmoMessaging.MessageHandler<ApiRequest> = async (req, res) => {
  const { endpoint, method, data } = req.body
  
  try {
    const result = await apiClient.request({
      endpoint,
      method,
      data
    })
    res.send({ success: true, data: result })
  } catch (error) {
    res.send({ success: false, error: error.message })
  }
}

export default handler

// ===== PORT HANDLERS =====
// src/background/ports/stream.ts
import type { PlasmoMessaging } from "@plasmohq/messaging"

type StreamRequest = {
  action: "subscribe" | "unsubscribe"
  channel: string
}

const handler: PlasmoMessaging.PortHandler<StreamRequest> = async (req, res) => {
  console.log("Stream port connected:", req.body)
  
  const { action, channel } = req.body
  
  if (action === "subscribe") {
    // Start streaming data
    const interval = setInterval(() => {
      res.send({
        channel,
        data: {
          timestamp: Date.now(),
          value: Math.random()
        }
      })
    }, 1000)
    
    // Cleanup on disconnect
    req.port.onDisconnect.addListener(() => {
      clearInterval(interval)
    })
  }
}

export default handler

// ===== CONTENT SCRIPTS =====
// src/contents/overlay.tsx
import cssText from "data-text:~styles/content.css"
import type { PlasmoCSConfig } from "plasmo"
import { useState } from "react"
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { ThemeProvider } from "~components/theme-provider"
import { ExtensionWidget } from "~components/extension-widget"

export const config: PlasmoCSConfig = {
  matches: ["<all_urls>"],
  exclude_matches: ["*://localhost/*"],
  css: ["font.css"]
}

const queryClient = new QueryClient()

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}

export const getShadowHostId = () => "ultimate-extension-root"

const ContentOverlay = () => {
  const [isOpen, setIsOpen] = useState(false)
  
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <div className="fixed bottom-4 right-4 z-[9999]">
          <ExtensionWidget isOpen={isOpen} onToggle={setIsOpen} />
        </div>
      </ThemeProvider>
    </QueryClientProvider>
  )
}

export default ContentOverlay

// src/contents/inject.ts
import type { PlasmoCSConfig } from "plasmo"

export const config: PlasmoCSConfig = {
  matches: ["<all_urls>"],
  run_at: "document_start",
  world: "MAIN"
}

// Inject into main world
window.__EXTENSION_INJECTED__ = true

// Expose API to webpage
window.extensionAPI = {
  version: chrome.runtime.getManifest().version,
  sendMessage: async (message: any) => {
    return new Promise((resolve) => {
      window.postMessage({
        source: "extension",
        type: "request",
        payload: message
      }, "*")
      
      const handler = (event: MessageEvent) => {
        if (event.data.source === "extension" && event.data.type === "response") {
          window.removeEventListener("message", handler)
          resolve(event.data.payload)
        }
      }
      
      window.addEventListener("message", handler)
    })
  }
}

// ===== POPUP UI =====
// src/popup/index.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { ThemeProvider } from "~components/theme-provider"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~components/ui/tabs"
import { HomeTab } from "./tabs/home"
import { SettingsTab } from "./tabs/settings"
import { DataTab } from "./tabs/data"
import "~styles/globals.css"

const queryClient = new QueryClient()

function IndexPopup() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="light">
        <div className="w-[400px] h-[600px] bg-background">
          <div className="p-4">
            <h1 className="text-2xl font-bold mb-4">Extension Control Panel</h1>
            
            <Tabs defaultValue="home" className="w-full">
              <TabsList className="grid w-full grid-cols-3">
                <TabsTrigger value="home">Home</TabsTrigger>
                <TabsTrigger value="data">Data</TabsTrigger>
                <TabsTrigger value="settings">Settings</TabsTrigger>
              </TabsList>
              
              <TabsContent value="home">
                <HomeTab />
              </TabsContent>
              
              <TabsContent value="data">
                <DataTab />
              </TabsContent>
              
              <TabsContent value="settings">
                <SettingsTab />
              </TabsContent>
            </Tabs>
          </div>
        </div>
      </ThemeProvider>
    </QueryClientProvider>
  )
}

export default IndexPopup

// ===== CORE UTILITIES =====
// src/core/storage.ts
import { Storage } from "@plasmohq/storage"
import { SecureStorage } from "@plasmohq/storage/secure"

export const storage = new Storage({
  area: "local"
})

export const syncStorage = new Storage({
  area: "sync"
})

export const secureStorage = new SecureStorage({
  area: "local"
})

// Typed storage keys
export type StorageKeys = {
  user: { id: string; email: string; name: string }
  settings: {
    theme: "light" | "dark" | "system"
    notifications: boolean
    autoSync: boolean
  }
  cache: Record<string, any>
}

// Storage helper with types
export class TypedStorage {
  private storage: Storage
  
  constructor(area: "local" | "sync" = "local") {
    this.storage = new Storage({ area })
  }
  
  async get<K extends keyof StorageKeys>(key: K): Promise<StorageKeys[K] | undefined> {
    return this.storage.get(key)
  }
  
  async set<K extends keyof StorageKeys>(key: K, value: StorageKeys[K]): Promise<void> {
    await this.storage.set(key, value)
  }
  
  async remove<K extends keyof StorageKeys>(key: K): Promise<void> {
    await this.storage.remove(key)
  }
}

export const typedStorage = new TypedStorage()

// src/core/api.ts
import { storage } from "./storage"

export class ApiClient {
  private baseUrl: string
  private token: string | null = null
  
  constructor(baseUrl: string = process.env.PLASMO_PUBLIC_API_URL || "") {
    this.baseUrl = baseUrl
    this.loadToken()
  }
  
  private async loadToken() {
    this.token = await storage.get("auth_token")
  }
  
  async request<T = any>({
    endpoint,
    method = "GET",
    data,
    headers = {}
  }: {
    endpoint: string
    method?: string
    data?: any
    headers?: Record<string, string>
  }): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`
    
    const config: RequestInit = {
      method,
      headers: {
        "Content-Type": "application/json",
        ...headers
      }
    }
    
    if (this.token) {
      config.headers["Authorization"] = `Bearer ${this.token}`
    }
    
    if (data && method !== "GET") {
      config.body = JSON.stringify(data)
    }
    
    const response = await fetch(url, config)
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`)
    }
    
    return response.json()
  }
}

export const apiClient = new ApiClient()

// src/core/auth.ts
import { Storage } from "@plasmohq/storage"
import { apiClient } from "./api"

export class AuthManager {
  private storage: Storage
  
  constructor() {
    this.storage = new Storage({ area: "local" })
  }
  
  async login(credentials: { email: string; password: string }) {
    try {
      const response = await apiClient.request({
        endpoint: "/auth/login",
        method: "POST",
        data: credentials
      })
      
      await this.storage.set("auth_token", response.token)
      await this.storage.set("user", response.user)
      
      return response.user
    } catch (error) {
      console.error("Login failed:", error)
      throw error
    }
  }
  
  async loginWithGoogle() {
    return new Promise((resolve, reject) => {
      chrome.identity.getAuthToken({ interactive: true }, async (token) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError)
          return
        }
        
        try {
          const response = await apiClient.request({
            endpoint: "/auth/google",
            method: "POST",
            data: { token }
          })
          
          await this.storage.set("auth_token", response.token)
          await this.storage.set("user", response.user)
          
          resolve(response.user)
        } catch (error) {
          reject(error)
        }
      })
    })
  }
  
  async logout() {
    await this.storage.remove("auth_token")
    await this.storage.remove("user")
  }
  
  async isAuthenticated(): Promise<boolean> {
    const token = await this.storage.get("auth_token")
    return !!token
  }
  
  async getUser() {
    return this.storage.get("user")
  }
}

export const authManager = new AuthManager()

export function initializeAuth() {
  // Setup auth state listeners
  chrome.identity.onSignInChanged.addListener((account, signedIn) => {
    console.log("Sign in state changed:", account, signedIn)
  })
}

// ===== COMPONENTS =====
// src/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "~lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

// src/components/extension-widget.tsx
import { useState } from "react"
import { X, MessageSquare } from "lucide-react"
import { Button } from "./ui/button"
import { sendToBackground } from "@plasmohq/messaging"
import { useQuery } from "@tanstack/react-query"

interface ExtensionWidgetProps {
  isOpen: boolean
  onToggle: (open: boolean) => void
}

export function ExtensionWidget({ isOpen, onToggle }: ExtensionWidgetProps) {
  const [message, setMessage] = useState("")
  
  const { data: status } = useQuery({
    queryKey: ["extension-status"],
    queryFn: async () => {
      const response = await sendToBackground({
        name: "ping"
      })
      return response
    },
    refetchInterval: 5000
  })
  
  if (!isOpen) {
    return (
      <Button
        size="icon"
        className="rounded-full shadow-lg"
        onClick={() => onToggle(true)}
      >
        <MessageSquare className="h-5 w-5" />
      </Button>
    )
  }
  
  return (
    <div className="bg-background border rounded-lg shadow-xl w-[350px] p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="font-semibold">Extension Assistant</h3>
        <Button
          size="icon"
          variant="ghost"
          onClick={() => onToggle(false)}
        >
          <X className="h-4 w-4" />
        </Button>
      </div>
      
      <div className="space-y-4">
        <div className="text-sm text-muted-foreground">
          Status: {status ? "Connected" : "Disconnected"}
        </div>
        
        <textarea
          className="w-full p-2 border rounded-md resize-none"
          rows={3}
          placeholder="Type your message..."
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
        
        <Button
          className="w-full"
          onClick={async () => {
            // Send message to background
            const response = await sendToBackground({
              name: "api",
              body: {
                endpoint: "/chat",
                method: "POST",
                data: { message }
              }
            })
            console.log("Response:", response)
            setMessage("")
          }}
        >
          Send Message
        </Button>
      </div>
    </div>
  )
}

// ===== UTILITIES =====
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date | string): string {
  const d = new Date(date)
  return d.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric"
  })
}

export function debounce<T extends (...args: any[]) => void>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}

// ===== ENVIRONMENT VARIABLES =====
// .env.example
PLASMO_PUBLIC_API_URL=https://api.yourdomain.com
PLASMO_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
PLASMO_PUBLIC_SUPABASE_KEY=your-anon-key
PLASMO_PUBLIC_GOOGLE_CLIENT_ID=your-google-client-id
PLASMO_PUBLIC_STRIPE_KEY=pk_test_xxx

# Private (not exposed to extension)
DATABASE_URL=postgresql://...
STRIPE_SECRET_KEY=sk_test_xxx
JWT_SECRET=your-secret-key

// ===== STYLES =====
// src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 10% 3.9%;
    --radius: 0.5rem;
  }
  
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

// src/styles/content.css
/* Styles for content script */
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

.extension-widget {
  font-family: "Inter", sans-serif !important;
  font-size: 14px !important;
  line-height: 1.5 !important;
  color: var(--foreground) !important;
}

/* Reset styles for shadow DOM */
:host {
  all: initial;
  font-family: "Inter", sans-serif;
}

// ===== README.MD =====
# Ultimate Chrome Extension Template

A comprehensive Chrome extension template with all modern features and best practices.

## Features

- üöÄ **Plasmo Framework** - Modern extension development
- ‚öõÔ∏è **React 18** - UI components
- üì¶ **TypeScript** - Type safety
- üé® **Tailwind CSS** - Styling
- üîÑ **React Query** - Data fetching
- üíæ **Storage API** - Local/sync storage with encryption
- üì® **Messaging System** - Background/content script communication
- üîê **Authentication** - OAuth and credential-based auth
- üåê **API Integration** - Ready-to-use API client
- üìä **Analytics** - Event tracking
- üéØ **Content Scripts** - Page injection and manipulation
- üñºÔ∏è **Shadow DOM** - Isolated UI components
- üîî **Notifications** - Browser notifications
- üìù **Context Menus** - Right-click actions
- ‚è∞ **Alarms** - Scheduled tasks
- üéõÔ∏è **Options Page** - Settings management
- üì± **Popup UI** - Extension popup
- üÜï **Side Panel** - Chrome 114+ side panel
- üõ†Ô∏è **DevTools** - Custom developer tools panel

## Quick Start

1. Clone this template:
```bash
git clone https://github.com/yourusername/ultimate-chrome-extension
cd ultimate-chrome-extension
```

2. Install dependencies:
```bash
npm install
# or
pnpm install
```

3. Set up environment variables:
```bash
cp .env.example .env.development
```

4. Start development:
```bash
npm run dev
```

5. Load extension in Chrome:
   - Open `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select the `build/chrome-mv3-dev` folder

## Project Structure

```
src/
‚îú‚îÄ‚îÄ background/          # Background service worker
‚îú‚îÄ‚îÄ contents/           # Content scripts
‚îú‚îÄ‚îÄ popup/             # Popup UI
‚îú‚îÄ‚îÄ options/           # Options page
‚îú‚îÄ‚îÄ components/        # Shared React components
‚îú‚îÄ‚îÄ core/             # Core utilities (storage, auth, api)
‚îú‚îÄ‚îÄ hooks/            # React hooks
‚îú‚îÄ‚îÄ lib/              # Utility functions
‚îî‚îÄ‚îÄ styles/           # Global styles
```

## Development

### Commands

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run test` - Run tests
- `npm run lint` - Lint code
- `npm run format` - Format code

### Key Concepts

1. **Messaging**: Use `@plasmohq/messaging` for communication
2. **Storage**: Use `@plasmohq/storage` for data persistence
3. **Content UI**: Use Shadow DOM for isolated components
4. **Background**: Keep service worker alive with alarms
5. **Types**: Use TypeScript for all code

## Building for Production

1. Update version in `package.json`
2. Build the extension:
```bash
npm run build
```
3. Package for distribution:
```bash
npm run package
```
4. Upload to Chrome Web Store

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT License - see LICENSE file for details